\section{Development practices}
\subsection{Introduction}
When developing a project, especially when the primary goal of the project is learning, it is important to consider the process.
With this in mind, the following section will elaborate on how the group has been working together.
The section will be divided into subsections regarding each type of problem, and how it was handled.

\subsection{Scrum}
The cooperation practices were heavily inspired by agile development, as it is predictable that several issues in a research-based project will arise during the period of the project.
However, rigorously following the Scrum principles was deemed unfeasible, as the project had a strict deadline, and a lack of an actual customer who could function as product owner.
With this in mind, principles from agile development, and especially Scrum, were used instead of strictly following one specific model, whenever applicable.
The process was based around sprints, a week in length, starting and ending on Tuesdays.

\subsection{Milestones}
Initially, after having decided on which area to work with, a set of milestones were defined that covered the whole project from start to project hand in.
The milestone plan was based around a rough estimate of the time it would take to write different sections of the report and the different code modules.

Below, the initial plan can be seen, where it is split into sprint index, start date and primary goal of the period:
\begin{enumerate}
	\item sprint01: 2018-09-11 - setup
	\item sprint02: 2018-09-18 - Start on analysis and theory
	\item sprint03: 2018-09-25 - Analysis done
	\item sprint04: 2018-10-02 - Architecture done
	\item sprint05: 2018-10-09 - Theory done
	\item sprint06: 2018-10-16 - Start on development + Start on documentation
	\item sprint07: 2018-10-23 - RASP -> NXT communication done.
	\item sprint08: 2018-10-30 - Movement-module works
	\item sprint09: 2018-11-06 - Basic Image recognition
	\item sprint10: 2018-11-13
	\item sprint11: 2018-11-20 - Motion Prediction module done
	\item sprint12: 2018-11-27 - Product done
	\item sprint13: 2018-12-04 - Documentation Done
	\item sprint14: 2018-12-11 - Conclusion and meta section done
	\item sprint15: 2018-12-18 - proofreading done [SPRINT IS ONLY 2 DAYS]
\end{enumerate}

This allowed keeping track of the progression of the project, however, the early time estimates were a bit optimistic, as the implementation of the machine learning and NXT code took significantly longer than first anticipated due to unforeseen obstacles.
Due to these complications, the timeline was repeatedly adjusted as the project went along, and ended up like the following:
\begin{enumerate}
	\item	sprint08: 2018-10-30 - Start on ML, and finish theory
	\item	sprint09: 2018-11-06 - Design Done
	\item	sprint10: 2018-11-13 - Image ML works
	\item	sprint11: 2018-11-20 - Consider whether doing Motion Prediction module
	\item	sprint12: 2018-11-27 - Solution done
	\item	sprint13: 2018-12-04 - Documentation Done
	\item	sprint14: 2018-12-11 - Conclusion and process analysis done
	\item	sprint15: 2018-12-18 - proofreading done [SPRINT IS ONLY 2 DAYS]
\end{enumerate}

At the end of a project a more detailed plan, which was made daily was used instead, primarily to keep track of the progression of the project, during the final weeks.

\subsection{Sprints}
All sprints started with a meeting, which was typically held on Tuesdays, as it allowed for work to be done before the weekend, with Monday being reserved for review and merging of the different issues, before the next meeting on Tuesday.
This meeting had three default points:
\begin{itemize}
	\item Standup
	\item Review
	\item Planning
\end{itemize}

During \textbf{standup}, each member reported on the issues they had the last sprint.
This included mentioning any impediments in solving a given problem, or discoveries based on specific tasks.
Presentations of interesting or important implementation details, would be covered in miscellaneous bullet points.

In a fully utilized Scrum environment you would have daily standup meetings, but this did not make sense since work on the project was not done on a daily basis.
We learned that Scrum makes more sense when working a full work week.
A problem stemming from this was the lack of clarity in regards to progress on every members issue, and whether the issue would be closed.
This problem was reduced later on as the group members learned to update each other and ask each other for updates through the chat service.
In the last two sprints, daily standups were introduced as everyone met in the group room on daily basis.

After the standup, a \textbf{review} followed.
The review evaluated on the previous sprint as a whole, such as progress and whether the issue estimations were correct, and the current and future direction of the project.
This created an iterative process of improvement, which helped with a large variety of issues.

\textbf{Planning} was where the weekly team-lead would present the issues that he had prepared for the sprint.
The team-lead was chosen each week, and would make sure people would close their given issues, and he would prepare a list of issues for the coming sprint.
Preparing the issues meant making sure their descriptions were acceptable, with a \textit{Definition of Done} and adding any relevant notes to the description.
At the meeting, the team-lead explained a given issue, and the whole team estimated the amount of points required to solve the given issue by using planning poker.
If estimations differed, a discussion in regards to the actual intended work of the issue would be held.

After the issues in the sprint had been assigned points, each member would say how many points they expected to be able to work through in the upcoming sprint.
If the amount of points in the pre-planned sprint was larger than the estimated amount to be burnable, issues would be moved out, and if it was smaller, more issues would be estimated.
Finally, each member would assign themselves to issues they wished to work on.

\section{Communication}
When communicating in a development team, face to face communication is preferred, which was the reasoning for a weekly standup meeting.
As every member of the group had a job, in addition to school, individual work was preferred in the beginning.
However as difficulties arose, especially in regards to NXT development, a weekly workday was introduced on Thursdays.
This could be through discussion, instant feedback on different work items, or using different techniques, such as pair programming.
Working together helped with development in these cases and provided valuable discussion and improved the speed of development considerably.
The principles of pair programming were also utilized when proof reading critical parts of the report, as a dynamic discussion of phrasing and topics, provided a larger variety of options.

To communicate during the week Slack was used, which is a chat platform, with both direct messaging and channels.
Channels were created for different purposes with the \texttt{general} channel mainly being used for communication that was essential to all members of the group, such as planning meeting times.
Channels like \texttt{report} and \texttt{development} were meant for discussion relating to the report or the development.
Slack allows the use of bots that can be triggered by events in Jira, Github or TeamCity which were used for issue tracking, version control and continuous integration, respectively.
This centralized all notifications regarding the project on one platform.

\section{Issue tracking}
Jira is an issue-tracking system with a large variety of features and integrations, that allows creating kanban boards.
Having an online issue-reporting system made it easy for the group members to add, update and read issues.
During the last two sprints, a physical kanban board was used instead, as it allowed for easier tracking of progress.

\section{Version Control}
For version control the Git protocol, through GitHub, was used, to keep track of different versions of the project, 2 main branches was used: a master branch, a develop branch and a series of feature branches.
Feature branches were used for solving issues, meaning that each issue on the kanban board, had a corresponding feature branch.

The develop branch served as sprint branches, and all feature branches are merged into the develop branch during the week.
These merges could only happen with a pull request that had been reviewed and approved by one or more members, and had successfully passed all tests.

The develop branch was merged into the master branch on a weekly basis after the weekly standup meeting.
As mentioned, whenever a pull request was created a set of tests are run.
These tests differ in nature, from readability tests to functionality tests.

Examples of readability tests include checking the \LaTeX code for multiple sentences on a single line.
This test was added to ease commenting in GitHub during the merge review process, as well as reduce the possibility of merge conflicts, as git merges individual lines.

Another example of cosmetic tests was code linting, which simply checked the Python and C code for any code deviating from the standards set by the group.
This includes, but is not limited to: indentation, spacing and naming conventions.
For Python, PyLint was used while the C linter was implemented by the group.
In addition to the cosmetic tests, functionality tests were also added.
The functionality tests primarily consisted of unit tests, but also included a few integration tests when applicable.
The Python code was tested with the default python unit testing framework, while the C code framework was written by the group.
An initial goal for the project, was to ensure a 75\% test coverage across the codebase.

Finally, the robot was tested extensively by hand, and the individual modules of the solution were also tested such as hardware tests, described in \autoref{des:sec:hwtest} and performance tests of the different image localization algorithms, described in \autoref{des:sec:performance}.

Conclusively, the development was greatly improved by the iterative practices, both regarding the abstractive practices of development, as well as the agile principles followed through sprints, testing and continuous integration.
The practices improves cooperation as well as velocity, especially during the final weeks of development, and should be a good foundation for a new project in the coming semesters.

\section{Continous Integration}
For continuous integration, the group used TeamCity with custom build scripts, to ensure that all builds were built correctly\cite{TeamCityHomepage}.
To prevent a branch with a failed build from being merged, the TeamCity server provides GitHub pull requests with status updates via the GitHub API, to ensure that failing branches were not mergeable.

Furthermore, the TeamCity server builds produces artifacts, such as code-coverage reports and a PDF document of the report.
Thus, an environment that is independent of developers is kept, meaning that some environment specific errors are avoided.
