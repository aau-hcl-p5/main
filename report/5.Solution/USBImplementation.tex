\section{USB implentation}
\label{sec:usbimp}
In Section~\ref{sec:usbdes} a high level description of the USB communication between the computer and the NXT was described.
This section will describe the specifics of the implementatio of the USB receiver on the NXT.

The USB receiver has 3 parts, which is also shown in Figure~\ref{fig:compusb}.

\subsection{Handshake}
The
\begin{lstlisting}[language=CSharp,label={lst:usbhandshake},caption={ecrobot\_device\_initialize method from nxt.c}]
    void ecrobot_device_initialize(void) {
        init_motor(NXT_PORT_A, 'y', 20);
        init_motor(NXT_PORT_B, 'x', 20);
        ecrobot_init_usb();
    }
\end{lstlisting}
Snippet~\ref{lst:usbhandshake} shows the initializion of the NXT device. 
\texttt{ecrobot\_device\_initialize} is invoked by NXTOSEK on program startup.
The essential function call for function call is the ecrobot\_init\_usb() call.
This function is a part of the NXTOSEK API and is required to use the NXT's USB port for communication.
As mentioned in Section~\ref{sec:usbdes}, this part posed a few challenges, as it was not clearly documented.
However the challenges were primarily on the computer side, and will not be elaborated further here.

The next part of the USB receival is the actual continous retrieval from the USB buffer.
\begin{lstlisting}[language=CSharp,label={lst:usbreceive},caption={get\_target\_location method from data\_receive.c}]
    bool get_target_location(T_TARGET_LOCATION *out_location) {
	int32_t len;
	uint8_t data[SIZEOF_USB_DATA];

    memset(data, 0, SIZEOF_USB_DATA); /* flush buffer */
	/* critical section */
	GetResource(USB_Rx);
	len = ecrobot_read_usb(data, 0, SIZEOF_USB_DATA); /* read USB data */
	ReleaseResource(USB_Rx);

	if (len > 0)
	{
		if (*((uint32_t *)data) == DISCONNECT_REQ)
		{
			/* disconnect current connection */
			ecrobot_disconnect_usb();
			show_init_screen();
			return false;
		}
		*out_location = *((T_TARGET_LOCATION *)data);
		display_target_location(*out_location);
		return true;
	}
	return false;
}
\end{lstlisting}
The get\_target\_location fuction handles both the second part of the USB receive, the continous read, and the third part, the potential disconnect.

The GetResource(USB\_Rx) call, locks the USB resource for other processes.
It then reads the data from the usb buffer, with the ecrobot\_read\_usb call, into the data unsigned integer data and releases the USB resource.
If nothing is read from the USB, meaning if the length of the read data is $0$, it returns false.

Next it checks if the data match the disconnect statuscode, which is defined as \texttt{0xFFFFFFFF} in the data\_receive.h header file.
if that is the case, it turns of the USB communication, and turns on the initialization screen.
Otherwise it sets the data that the out\_location pointer points to, to be the read data.
Finally it displays the target location to the NXT screen, which is mostly used for debugging.

The get\_target\_location function is called from the logic.c file, which contains the logic for the device.
Logic.c next calls the move function, which uses the target\_location to aim the robot.
This is described in the next section, Section~\ref{sec:movement}.
