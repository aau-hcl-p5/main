\section{Scheduling}\label{solution:scheduling}
As described in Subsection~\ref{Design:Scheduling}, the scheduling method is cyclic executive. 
On Snippet~\ref{lst:MainTask} the implementation of the main task of the system is shown. 
The main task is responsible for the scheduling of the system.

This task consists of two loops that correspond to the two states that the system can operate in: calibrating and normal execution.
As can be seen on Snippet~\ref{lst:MainTask} lines 3 to 12 the calibration state has to be completed before the system can start the normal execution. 
On lines 13 to 25 the actual scheduling of the running all the methods need can be seen, these method will be called once per major cycle hence being true to the deadline. 

\begin{lstlisting}[language=CSharp,label={lst:MainTask},caption={MainTaks method from logic.c}]
TASK(MainTask)
{
    for (;;) {
        calibrating = true;
        show_init_screen();
        while(!get_status_code(&current_status, 0));

        if (current_status == READY_FOR_CALIBRATION)
        {
            calibrate(false);
        }
        calibrating = false;
        for(;;)
        {
            WaitEvent(newMajorCycleEvent);
            keep_USB_alive();
            receive_data();
            if (current_status == DISCONNECTED_REQ) {
                stop();
                break;
            }
            move_motors();
            handle_laser();
            update_display();
            ClearEvent(newMajorCycleEvent); 
        }
    }
    TerminateTask();
}
\end{lstlisting}

In order to time the major cycle, the \textit{user\_1ms\_isr\_type2} method, that can be seen on Snippet~\ref{lst:user1msisrtype2}, is used to raise the event of the major cycle. 
The method activated by an system interrupt ensuring that the method will be called once every millisecond. 
\begin{lstlisting}[language=CSharp,label={lst:user1msisrtype2},caption={user\_1ms\_isr\_type2 method from nxt.c}]
void user_1ms_isr_type2(void)
{
    (void)SignalCounter(SysTimerCnt);
    SetEvent(MainTask, newMajorCycleEvent);
    if(calibrating)
        keep_USB_alive();
}
\end{lstlisting}

\todo{Tilf√∏j execution times for at argumentere for at vi kun har en major cycle}

As part of the implementation of the cyclic executive scheduling method, an event is waiting to be raised after each cycle iteration. 
On Snippet~\ref{lst:newMajorCycleEvent} the event is specified on the operation system level, such that it can be raised by the interrupt. 
\begin{lstlisting}[language=CSharp,label={lst:newMajorCycleEvent},caption={newMajorCycleEvent event from nxt.oil}]
EVENT newMajorCycleEvent{
    MASK = AUTO;
};
\end{lstlisting}

The system only has one task, which is declared with the properties shown on Snippet~\ref{lst:MainTask}. 
The properties specifies to the operating system how the task shall run and that the event from before is related to the task.
\begin{lstlisting}[language=CSharp,label={lst:MainTask},caption={MainTaks task from nxt.oil}]
    TASK MainTask {
      AUTOSTART = TRUE 
        {
          APPMODE = appmode1;
        };
      PRIORITY = 1;
      ACTIVATION = 1;
      SCHEDULE = FULL;
      STACKSIZE = 512;
      RESOURCE = USB_Rx;
      EVENT = newMajorCycleEvent;
};
\end{lstlisting}