\section{Movement module}
\label{sec:movement}
The movement module is responsible for making the turret rotate with the intent of aiming at the target.
The module consists of multiple methods each responsibility of a subset of the overall functionality.
In the following subsections, the movement module will be elaborated upon and some of the primary methods will be explained.

\subsection{Initialization}
To utilize the hardware components, they have to be initialized.
\autoref{lst:DeviceInit} shows this process in relation to the different external devices, the motors, laser, and the USB port.
The motors and the lasers are assigned to a specific port, and the USB communication is initialized, as required by nxtOSEK.
\begin{lstlisting}[language=CSharp, label={lst:DeviceInit},caption={ecrobot\_device\_initialize method from nxt.c}]
void ecrobot_device_initialize(void) {
	x_motor = NXT_PORT_A;
	x_motor_speed = 0;
	y_motor = NXT_PORT_B;
	y_motor_speed = 0;
	
	
	ecrobot_set_motor_speed(x_motor, 0);
	nxt_motor_set_count(x_motor, 0);
	ecrobot_set_motor_speed(y_motor, 0);
	nxt_motor_set_count(y_motor, 0);
	
	init_laser(NXT_PORT_C, NXT_PORT_C);
	ecrobot_init_usb(); /* init USB */
}
\end{lstlisting}
The speed is set to zero, and the initial rotation is set to zero, which results in the starting point being the global zero of the device.


Whenever a target is acquired, the \texttt{move} function is called.
\autoref{lst:MoveMotors} shows this function, which first fetches the required motor power and stores this in a global variable.
A native function is called, which makes the motor rotate with the specified power.
The usage of a global variable, is for usage in the screen module.
Movement, is always relative to current location, as the absolute location of the target is not known, rather the information is based on the center of the camera, and with it the laser.

\begin{lstlisting}[language=CSharp,caption={move method from movement.c},label={lst:MoveMotors}]
  void move(T_VECTOR target) {
	// speed is 0 when distance is small enough.
	x_motor_speed = get_speed_by_distance(target.x, AXIS_X);
	y_motor_speed = get_speed_by_distance(target.y, AXIS_Y);
	set_motor_speed(AXIS_X, x_motor_speed);
	set_motor_speed(AXIS_Y, y_motor_speed);
}
\end{lstlisting}


The \texttt{move} function uses the \texttt{get\_speed\_by\_distance} function to get the required speed based on the neural network discussed in \autoref{sec:calibration} and a modifier based on the length of the \texttt{target} vector.
This functionality is shown in \autoref{lst:getspeed}.

\begin{lstlisting}[language=CSharp,caption={get\_speed\_by\_distance method from movement.c},label={lst:getspeed},firstnumber={109}]
int8_t get_speed_by_distance(int8_t distance, T_AXIS_TYPE axis) {
	if (distance < MOTOR_DEADZONE && distance > -MOTOR_DEADZONE) {
		return 0;
	}
	
	// timed by 1 if in the positive direction, and -1 if in the negative
	int8_t lower_bound = get_minimum_power(axis, distance >= 0) * ((distance >= 0) ? 1 : -1);
	int8_t range = axis == AXIS_X ? POWER_RANGE_X : POWER_RANGE_Y;
	
	return (range * distance / MAX_INPUT_VALUE) + lower_bound;
}
\end{lstlisting}

If the distance to the target is sufficiently small, the motors should not move, which is done by checking whether the distance is less than a constant.
If this is the case, the returned speed will be zero.
This \texttt{MOTOR\_DEADZONE} constant is by default 1, meaning that the turret as to aim directly at the target.

Alternatively, the function will find the minimum power required to move in the wanted direction on the relevant axis.
The speed is then timed by $1$ or $-1$ to make sure that the lower bound has the same direction as the distance.

The distance is then mapped into a range, which is a different range based on the axis, in the way described in \autoref{sec:mappingcompvis}.

When the scheduler either is on target or a target cannot be seen, the speed is set to $0$.
As the system uses the \texttt{ecrobot\_set\_motor\_speed} function, and not the \texttt{nxt\_motor\_set\_speed} function, the motors are automatically set to 'brake', which results in the motor locking when not moving.
\begin{lstlisting}[language=CSharp,label={lst:StopMotors},caption={stop\_motors method from movement.c}]
void stop_motors(){
  ecrobot_set_motor_speed(x_motor, 0);
  ecrobot_set_motor_speed(y_motor, 0);
}
\end{lstlisting}

These methods are utilized to aim the turret, however usage of these methods, and handling target location, are done in the scheduler, and understand the context of the movement module requires understanding the scheduler.