\section{Movement module}
\label{sec:movement}
The movement module is responsible for making the turret move towards a target provided by the machine intelligence part of the system.
The module consists of multiple methods which is responsible for minor areas of the overall function.
In the following subsections, the movement module will be elaborated upon and some of the primary methods will be explained.

\subsection{The motors}
\autoref{lst:InitMotor} shows the initialization of the ports on the NXT.
The motors and the lasers are assigned to ports, and the USB communication is initialized, as required by nxtOSEK.
\begin{lstlisting}[language=CSharp, label={lst:DeviceInit},caption={ecrobot\_device\_initialize method from nxt.c}]
/* Initializes motors with their direction */
void ecrobot_device_initialize(void) {
    init_motor(NXT_PORT_A, 'y', 20);
    init_motor(NXT_PORT_B, 'x', 20);
    init_laser(NXT_PORT_C, NXT_PORT_C);
    ecrobot_init_usb(); /* init USB */
}
\end{lstlisting}

\begin{lstlisting}[language=CSharp,label={lst:InitMotor},caption={init\_motor method from movement.c}]
bool init_motor(uint8_t motor_id, char orientation, uint16_t speed){
  if(orientation == AXIS_X){
    x_motor = motor_id;
    x_motor_speed = speed;
    ecrobot_set_motor_speed(x_motor, 0);
    nxt_motor_set_count(x_motor, 0);
    current_location.x = ecrobot_get_motor_rev(motor_id);
    return true;
  }
  else if(orientation == AXIS_Y){
    y_motor = motor_id;
    y_motor_speed = speed;
    ecrobot_set_motor_speed(y_motor, 0);
    nxt_motor_set_count(y_motor, 0);
    current_location.y = ecrobot_get_motor_rev(motor_id);
    return true;
  }
  return false;
}
\end{lstlisting}
\autoref{lst:DeviceInit} shows the \texttt{init\_motor} method.
The method checks for the initialization.
The method is branched, based on the axis that is given as a parameter.
The orientation parameter is used used to distinguish between the two motors connected to the NXT.
The speed can be any value between $0$ and $100$.

\subsection{The motion}
When a target has been located, the computer will send the information to the NXT.
The NXT will then begin its movement towards the target.
The target location is stored in a struct containing all relevant information about the target namely its coordinates and a timestamp on the information.

The move method is responsible for the actual activation of the individual motors.
The method can be seen on \autoref{lst:MoveMotors} and it will activate the motors according to the targets location and where it is currently aiming.
\begin{lstlisting}[language=CSharp,caption={move method from movement.c},label={lst:MoveMotors}]
  void move(T_VECTOR target) {
    // speed is 0 when distance is small enough.
    set_motor_speed('x', get_speed_by_distance(target.x, 'x'));
    set_motor_speed('y', -get_speed_by_distance(target.y, 'y'));
}
\end{lstlisting}

\todo{Er det her up to date.}
The move method makes use of the helper method \texttt{get\_speed\_by\_distance}, as seen on \autoref{lst:getspeed}, which gets the speed at which the motors should move.
The speed depends on the distance between the detected object and the center of the image, as high precision is not required until the target is close to the center, the center being when the robot is aimed directly at the target.
In the first if sentence, it is checked whether the distance to the target is lower than a constant \texttt{MOTOR\_DEADZONE}.
If the distance is smaller than the lowest amount of movement possible, it will return 0 and terminate.
Otherwise, the required power for the given axis will be calculated using the get\_required\_power method.

\begin{lstlisting}[language=CSharp,caption={get\_speed\_by\_distance method from movement.c},label={lst:getspeed}]
int8_t get_speed_by_distance(int8_t distance, char axis) {
  if (distance < MOTOR_DEADZONE && distance > -MOTOR_DEADZONE) {
      return 0;
  }

  uint8_t lower_bound = get_required_power(axis, distance >= 0);
  uint8_t range = 50;

  // if distance is negative, then MOTOR_SPEED_LOWER_BOUND should be negative,
  // otherwise we don't get a value in the expected range
  int8_t actual_lower_bound = lower_bound * ((distance >= 0) ? 1 : -1);

  return -((distance * range) / MAX_INPUT_VALUE + actual_lower_bound);
}
\end{lstlisting}

Once the turret is aiming at the target, the motion should be terminated.
If the power is removed from the motors, they will lose their stiffness and the entire turret will power down.
To avoid this, the motors have a function to set the speed of the motors to $0$, resulting in the motors locking themselves in position.
As shown on \autoref{lst:StopMotors} this method is very simple but effective.
\begin{lstlisting}[language=CSharp,label={lst:StopMotors},caption={stop\_motors method from movement.c}]
void stop_motors(){
  nxt_motor_set_speed(x_motor, 0, 1);
  nxt_motor_set_speed(y_motor, 0, 1);
}
\end{lstlisting}

Based on the methods described above, the LEGO turret is able to move based on the input given by the machine intelligence.
Hence the purpose of the movement module is to facilitate the movement of the turret which has thereby been accomplished.
