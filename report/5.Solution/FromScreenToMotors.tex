\section{Mapping between computer vision and movement}
Two functions are needed to translate the screen position into a velocity on the motors.
The first task is to translate the screen position into a format usable for the USB transfer, and then transform that format into a motor velocity.\todo{Should this be velocity or speed?}

\subsection{Screen to motors}
To translate the position on the screen into a velocity two functions are needed.
First of all, it is necessary to make a function maps the numbers correctly. \todo{Which numbers precisely?}

This function will require a 2d vector named \textit{pos} as input. \todo{what is pos}

The next goal is to take a location on the screen and translate it into a 8-bit value. \todo{why} 
Due to the resolution of the camera that is used, the range on the screen is $0 - 480$ on one axis and $0 - 640$ on the other.
The range on the \textit{out} \todo{what is out} is per default between 0 and 255, however, as it will be beneficial to later change this into an either positive or negative velocity, based on direction, it will be beneficial to center it around 0.
This results in the values being between $-127$ and $127$.

For the function, two constants are defined: \\
$$in\_max = (480,640)$$\\
$$out\_max = 127$$

A function that maps the screen position to be zero centred: 
$$
in_\text{max}/2 - pos
$$

Mapping this range to a new range, is done by first translating the range from $-240$ to $320$ to a range between $-1$ and $1$.
This is defined as:
$$
in_\text{max}/2 - pos)/(in_\text{max}/2
$$


This value is then multiplied with the desired \textit{out\_range}:
$$
(in\_max/2 - pos)/(in\_max/2) \cdot out\_max
$$

This leaves us with a value between $-127$ and $127$. 
However, this results in the same precision in the lower end of the scale as the high end.
Meaning that, when the target is far away, the same precision will be archived as when it is close, and it was deemed that precision is more important closer to the center, since only minor, but precise, adjustments will be needed.
Utilizing this logic, it is very similar to the same principles of floating point precision and can be solved by making a quadratic function:

$$
f(pos) = ((in_\text{max}/2 - pos)/(in_\text{max}/2))^2 \cdot out_\text{max}
$$

However, a minor problem with this formula is that taking the position to the power of 2 removes the direction of the given axis due to the effect of squaring a negative number.
To solve this, the result is multiplied with ether $-1$ or $1$ on each axis to retain the direction.

$$
f(pos) = ((in_\text{max}/2 - pos)/(in_\text{max}/2))^2 \cdot dir(pos) \cdot out_\text{max}
$$

\subsection{From USB to motors}
The NXT receives a vector in range $(-127 -> 127, -127 -> 127)$. \todo{correct mathematical notation?}
This vector should be mapped to the speed of the motor which is a value between $-100$ and $100$ on each axis where the number corrosponds to a percentage-wise speed in either a positive or negative direction.

The output of the USB is an 8-bit integer, and the input of the motor is also an int.
The easiest way to do these calculations is by simply mapping the ranges directly onto one another.
However, we rarely want full speed, nor do we want 0 speed as the motors oftentimes will not move until reaching a power level of 10 to 20 due to sheer weight of the attached LEGO components.
Therefore. the actual range was decided to be between $-30$ and $-10$ and likewise in the positive direction.

These values of $\pm10$ and $\pm30$ should obviously be tweakable, but in these examples, 10 and 30 will be used for the sake of simplicity. 
Input, in these constants, is the input of the function, which is the output of the USB module.

	$$lower\_bound = 10$$
	$$upper\_bound = 30$$
	$$input\_upperbound = 127$$
	$$range = upper\_bound - lower\_bound$$

Normally, mapping from input to output would be translating the input into a range of $-1$ to $1$, however, this required floating point precision since it would otherwise result in simply getting -1, 0 or 1, so instead the order is changed up a bit:

$$
speed(pos) = (pos \cdot range)/input_\text{upperbound} + (dir(pos) \cdot lowerbound)
$$

An issue with direction rises again with direction, because of lowerbound.
This is fixed by using the direction, so we actually uses the bound correctly. \todo{I do not like these two sentences, pls fix}