\section{Real-time systems}\label{Theory:RTS}
In order to guarantee that a computer system is able to function in a time critical environment i.e. car controllers and rockets, it is essential that the software of the system is true to its deadlines. 
In the following section, the different methods related to real-time systems will be elaborated.

\subsection{Scheduling}
When creating a real-time systems an essential part of making such systems is the ability to make the system schedulable.
Being scheduable means that all tasks have to be true to their deadlines and their periods. 
The period is specified by the requirements of the system and specifies how often a given task shall be completed.
Likewise, a deadline is specified by the requirements of the system and defines how far into the period the task must be completed.
Multiple methods can be used to determine whether a system is schedulable or not, but the base principle of all the methods is the same. 
There are tree main aspects that most general purpose scheduling algorithms emphasize:
\paragraph{Fairness} meaning that in general purpose systems it is important that all processes are granted execution time thus preventing starvation of a given process. 
\paragraph{Efficiency} meaning that since the scheduler is invoked very often in a general purpose operation system it needs to be efficient in order avoid wasting execution time on the CPU. 
\paragraph{Throughput} of a system, meaning the number of processes that are completed doing a given time period.
This aspect is related to efficiency since the CPU should be idle as little as possible. 

All these aspects are related to general purpose schedulers found in the most commonly used operating systems. 
However, these aspects are not relevant for real-time systems since the main focus of those systems is the \textit{timing} requirements of each process.
In order to determine the schedulability of a real-time system it needs to have a fixed set of processes which needs to be periodic in order to determine that it is schedulable.


In the following part, some of the different methods will be elaborated. 

\subsubsection{Cyclic Executives}
One of the simplest scheduling methods is the cyclic executives method, which is also known as timeline scheduling.
This method only allows one process or task to be executed at a time. 
When using this method, the schedule of which a process is executed is determined by a \textit{major cycle} and a \textit{minor cycle}.
The \textit{major cycle} is specified by calculating the Greatest Common Divisor (GCD) of all task periods in the system.
While the \textit{minor cycle} is defined by the Least Common Multiple (LCD) of all task periods in the system. 
The major cycle specifies a deadline of which all process has to be completed at least once.
The minor cycle specifies the interval of which at least one given task should have completed once. 

Since cyclic executives is a very simple scheduling method it is easy to implement and analyse, likewise it is also one of the most commonly used schedueling methods in real-time systems\cite{RealTimeEmbeddedSystems}. 

\subsubsection{Task-based scheduling}
Another commonly used scheduling method in real-time systems is the task-based method. 
This method is based on tasks that each have a given priority.

When using the task-based priority scheduling method, each task is given a fixed priority before run-time which can not be changed.
The priority of a task is not an indication of the importance of the task it is a simply a priority to make the system scheduable\cite{RealTimeEmbeddedSystems}. 
The priority of a task can be set by using a method called \textit{Earliest deadline first}.
\textbf{Earliest deadline first} means that it is the task with the earliest deadline that is allowed to execute first.
The next task to execute is the one with nearest upcoming deadline.

This scheduling method can work both with and without pre-emption of tasks, meaning that a running task can be set on hold when a higher priority task is ready to run.
When using this method for scheduling, a task with a low priority is allowed to run if no other task with a higher priority is ready to run. 
Given a low priority task is running and a higher priority task is marked as ready, the low priority task will be pre-empted in order to allow the higher priority to run.

\section{Response time analysis}
Response time analysis is an exact schedulability test for an fixed-priority  assignment scheme on a single-processor system. 
The response time analysis allows for prediction of the worst-case response time for each task which depends on the interference due to execution of higher priority tasks. 
The worst-case response times are then compared to with the corresponding tasks deadlines to evaluate whether all tasks meets their deadlines. 

Doing execution of a task, the task can be pre-empted if a higher priority task is released. 
For this reason the response time of lower priority tasks suffer a certain amount of interference from the higher priority tasks during their execution. 
Therefore the worst-case response time $R_i$ of a task $\tau_i$ is computed as the sum of its computation time $C_i$ and the worst-case interference $I_i$ it experiences, this is represented as follows:
\begin{equation}
R_i = C_i + I_i
\end{equation}

The contribution of each higher priority task to the overall worst-case interference has to be evaluated individually by considering the interference of a single task $\tau_j$ of higher priority than $\tau_i$.
The exact number of releases can be computed by means of the ceiling function as follows:
\begin{equation}

\end{equation}